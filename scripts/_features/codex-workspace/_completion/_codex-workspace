#compdef codex-workspace cw codex-workspace-refresh-opt-repos codex-workspace-reset-repo codex-workspace-reset-work-repos codex-workspace-rm

__codex_workspace_container_names() {
  emulate -L zsh -o extendedglob

  command -v docker >/dev/null 2>&1 || return 0

  local prefix="${CODEX_WORKSPACE_PREFIX:-codex-ws}"
  local -a names=()
  names=(${(f)"$(command docker ps -a --format '{{.Names}}' 2>/dev/null || true)"})

  local name
  for name in "${names[@]}"; do
    [[ "$name" == "${prefix}-"* ]] || continue
    print -r -- "$name"
  done

  return 0
}

_codex-workspace() {
  emulate -L zsh -o extendedglob

  local context='' state='' state_descr=''
  local -a line=()
  typeset -A opt_args=()

  typeset -i orig_current="$CURRENT"
  typeset -a orig_words=("${words[@]}")

  typeset -a containers=()
  containers=(${(f)"$(__codex_workspace_container_names)"})

  case "${service-}" in
    codex-workspace|cw)
      local cmd="${orig_words[2]-}"
      cmd="${cmd%%[[:space:]]#}"

      if (( orig_current == 2 )); then
        local cur="${orig_words[2]-}"
        cur="${cur%%[[:space:]]#}"

        if [[ "$cur" == -* ]]; then
          typeset -a ws_opts=()
          ws_opts=(
            '-h:Show help'
            '--help:Show help'
          )
          _describe -t options 'option' ws_opts && return 0
          return 0
        fi

        typeset -a subcmds=()
        subcmds=(
          'create:Create workspace'
          'ls:List workspaces'
          'exec:Exec into workspace (default: zsh)'
          'rm:Remove workspace(s)'
          'tunnel:Open a tunnel for a workspace'
        )
        _describe -t commands 'codex-workspace command' subcmds && return 0
        _message 'subcommand (create|ls|rm|exec|tunnel)'
        return 0
      fi

      if (( orig_current > 2 )) && [[ "${orig_words[orig_current-1]-}" == "--private-repo" ]]; then
        _message 'private repo (owner/repo or URL)'
        return 0
      fi

      case "$cmd" in
        ls)
          local cur="${orig_words[orig_current]-}"
          cur="${cur%%[[:space:]]#}"
          if [[ "$cur" == -* ]]; then
            typeset -a list_opts=()
            list_opts=(
              '-h:Show help'
              '--help:Show help'
            )
            _describe -t options 'option' list_opts && return 0
            return 0
          fi
          return 0
          ;;
        create)
          if (( orig_current > 2 )) && [[ "${orig_words[orig_current-1]-}" == "--name" ]]; then
            _message 'workspace name'
            return 0
          fi

          local cur="${orig_words[orig_current]-}"
          cur="${cur%%[[:space:]]#}"
          if [[ "$cur" == -* ]]; then
            typeset -a ws_opts=()
            ws_opts=(
              '-h:Show help'
              '--help:Show help'
              '--no-extras:Do not clone ~/.private or extra repos under /work'
              '--no-work-repos:Do not clone any repos into /work (requires --name)'
              '--name:Workspace name (required with --no-work-repos)'
              '--private-repo:Seed container ~/.private from repo (owner/repo or URL)'
            )
            _describe -t options 'option' ws_opts && return 0
            return 0
          fi

          if (( ${orig_words[(I)--no-work-repos]} > 0 )); then
            _message 'no positional args (use --name)'
            return 0
          fi

          _message 'repo (owner/repo or URL; repeatable; default from CWD git)'
          return 0
          ;;
        rm)
          local cur="${orig_words[orig_current]-}"
          cur="${cur%%[[:space:]]#}"

          # Complete rm flags when the current word looks like an option.
          if [[ "$cur" == -* ]]; then
            typeset -a rm_opts=()
            rm_opts=(
              '-h:Show help'
              '--help:Show help'
              '--all:Remove all workspaces'
              '-y:Skip confirmation'
              '--yes:Skip confirmation'
            )
            _describe -t options 'option' rm_opts && return 0
            return 0
          fi

          # If --all is present, don't complete container names.
          if (( ${orig_words[(I)--all]} > 0 )); then
            return 0
          fi

          # Find the first non-option arg after the rm subcommand.
          local -i idx=3
          local workspace=''
          while (( idx < orig_current )); do
            local w="${orig_words[idx]-}"
            case "$w" in
              -h|--help)
                return 0
                ;;
              --all)
                idx=$((idx + 1))
                ;;
              -y|--yes)
                idx=$((idx + 1))
                ;;
              *)
                workspace="$w"
                break
                ;;
            esac
          done

          # Workspace already provided; nothing more to complete.
          [[ -n "$workspace" ]] && return 0

          if (( ${#containers[@]} > 0 )); then
            _values 'workspace container' $containers && return 0
          fi
          _message 'workspace container'
          return 0
          ;;
        exec)
          if (( orig_current > 2 )); then
            local prev="${orig_words[orig_current-1]-}"
            if [[ "$prev" == "-u" || "$prev" == "--user" ]]; then
              _message 'user (default: codex)'
              return 0
            fi
          fi

          local cur="${orig_words[orig_current]-}"
          cur="${cur%%[[:space:]]#}"

          if [[ "$cur" == -* ]]; then
            typeset -a exec_opts=()
            exec_opts=(
              '-h:Show help'
              '--help:Show help'
              '--root:Exec as root'
              '-u:Exec as user'
              '--user:Exec as user'
            )
            _describe -t options 'option' exec_opts && return 0
            return 0
          fi

          # Find the first non-option arg after the exec subcommand.
          local -i idx=3
          local workspace=''
          while (( idx < orig_current )); do
            local w="${orig_words[idx]-}"
            case "$w" in
              -h|--help)
                return 0
                ;;
              --root)
                idx=$((idx + 1))
                ;;
              -u|--user)
                idx=$((idx + 2))
                ;;
              --user=*)
                idx=$((idx + 1))
                ;;
              --)
                idx=$((idx + 1))
                ;;
              -*)
                idx=$((idx + 1))
                ;;
              *)
                workspace="$w"
                break
                ;;
            esac
          done

          # Workspace already provided; nothing more to complete.
          [[ -n "$workspace" ]] && return 0

          if (( ${#containers[@]} > 0 )); then
            _values 'workspace container' $containers && return 0
          fi
          _message 'workspace container'
          return 0
          ;;
        tunnel)
          if (( orig_current > 2 )) && [[ "${orig_words[orig_current-1]-}" == "--name" ]]; then
            _message 'tunnel name (<=20 chars)'
            return 0
          fi

          local cur="${orig_words[orig_current]-}"
          cur="${cur%%[[:space:]]#}"

          typeset -a tunnel_opts=()
          tunnel_opts=(
            '-h:Show help'
            '--help:Show help'
            '--detach:Start tunnel in background'
            '--name:VS Code tunnel name (<=20 chars)'
          )

          # Complete tunnel flags when the current word looks like an option.
          if [[ "$cur" == -* ]]; then
            _describe -t options 'option' tunnel_opts && return 0
            return 0
          fi

          # Find the first non-option arg after the tunnel subcommand.
          local -i idx=3
          local workspace=''
          while (( idx < orig_current )); do
            local w="${orig_words[idx]-}"
            case "$w" in
              -h|--help)
                return 0
                ;;
              --name)
                idx=$((idx + 2))
                ;;
              --name=*)
                idx=$((idx + 1))
                ;;
              --detach)
                idx=$((idx + 1))
                ;;
              -*)
                idx=$((idx + 1))
                ;;
              *)
                workspace="$w"
                break
                ;;
            esac
          done

          # Workspace already provided; complete flags (even without a '-' prefix).
          if [[ -n "$workspace" ]]; then
            _describe -t values 'option' tunnel_opts && return 0
            return 0
          fi

          if (( ${#containers[@]} > 0 )); then
            _values 'workspace container' $containers && return 0
          fi
          _message 'workspace container'
          return 0
          ;;
        *)
          _message 'subcommand (create|ls|rm|exec|tunnel)'
          return 0
          ;;
      esac
      ;;

    codex-workspace-rm)
      _arguments -C \
        '(-h --help)'{-h,--help}'[Show help]' \
        '(-y --yes)'{-y,--yes}'[Skip confirmation]' \
        '--all[Remove all workspaces]' \
        '1:workspace:->workspaces'

      case "${state-}" in
        workspaces)
          if (( ${words[(I)--all]} > 0 )); then
            return 0
          fi
          if (( ${#containers[@]} > 0 )); then
            _values 'workspace container' $containers && return 0
          fi
          _message 'workspace container'
          return 0
          ;;
      esac

      return 0
      ;;

    codex-workspace-refresh-opt-repos)
      _arguments -C \
        '(-h --help)'{-h,--help}'[Show help]' \
        '(-y --yes)'{-y,--yes}'[Skip confirmation]' \
        '1:container:->workspaces'

      case "${state-}" in
        workspaces)
          if (( ${#containers[@]} > 0 )); then
            _values 'workspace container' $containers && return 0
          fi
          _message 'workspace container'
          return 0
          ;;
      esac

      return 0
      ;;

    codex-workspace-reset-repo)
      _arguments -C \
        '(-h --help)'{-h,--help}'[Show help]' \
        '(-y --yes)'{-y,--yes}'[Skip confirmation]' \
        '--ref=[Remote/branch ref (default: origin/main)]:ref' \
        '1:container:->workspaces' \
        '2:repo dir:->repo_dir'

      case "${state-}" in
        workspaces)
          if (( ${#containers[@]} > 0 )); then
            _values 'workspace container' $containers && return 0
          fi
          _message 'workspace container'
          return 0
          ;;
        repo_dir)
          _message 'repo dir (e.g. /work/OWNER/REPO)'
          return 0
          ;;
      esac

      return 0
      ;;

    codex-workspace-reset-work-repos)
      _arguments -C \
        '(-h --help)'{-h,--help}'[Show help]' \
        '(-y --yes)'{-y,--yes}'[Skip confirmation]' \
        '--root=[Root dir inside container (default: /work)]:root:(/work)' \
        '--depth=[Max search depth (default: 3)]:depth' \
        '--ref=[Remote/branch ref (default: origin/main)]:ref' \
        '1:container:->workspaces'

      case "${state-}" in
        workspaces)
          if (( ${#containers[@]} > 0 )); then
            _values 'workspace container' $containers && return 0
          fi
          _message 'workspace container'
          return 0
          ;;
      esac

      return 0
      ;;
  esac

  return 0
}

compdef _codex-workspace codex-workspace
compdef _codex-workspace codex-workspace-refresh-opt-repos
compdef _codex-workspace codex-workspace-reset-repo
compdef _codex-workspace codex-workspace-reset-work-repos
compdef _codex-workspace codex-workspace-rm

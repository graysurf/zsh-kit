#compdef git-lock

__git_lock_labels() {
  emulate -L zsh

  local toplevel repo_id lock_dir file
  lock_dir="$ZSH_CACHE_DIR/git-locks"

  toplevel="$(command git rev-parse --show-toplevel 2>/dev/null)" || return 0
  repo_id="${toplevel:t}"

  [[ -d "$lock_dir" ]] || return 0

  for file in "$lock_dir/${repo_id}-"*.lock(N); do
    [[ -f "$file" ]] || continue
    local label="${file:t}"
    label="${label#${repo_id}-}"
    label="${label%.lock}"
    print -r -- "$label"
  done

  return 0
}


_git-lock() {
  emulate -L zsh

  local context state state_descr
  local -a line
  typeset -A opt_args

  _arguments -s -C \
    '1:command:((lock\:Save\ commit\ hash\ to\ lock \
                 unlock\:Reset\ to\ a\ saved\ commit \
                 list\:Show\ all\ locks \
                 copy\:Duplicate\ a\ lock\ label \
                 delete\:Remove\ a\ lock \
                 diff\:Compare\ two\ locks \
                 tag\:Create\ a\ tag\ from\ a\ lock))' \
    '*::args:->args'

  local subcmd="${line[1]-${words[2]-}}"

  case "$subcmd" in
    unlock|delete)
      _values 'label' $(__git_lock_labels)
      ;;
    copy)
      if (( CURRENT == 3 )); then
        _values 'source label' $(__git_lock_labels)
      elif (( CURRENT == 4 )); then
        _message 'target label'
      fi
      ;;
    diff)
      if (( CURRENT == 3 || CURRENT == 4 )); then
        _values 'label' $(__git_lock_labels)
      fi
      ;;
    tag)
      if (( CURRENT == 3 )); then
        _values 'git-lock label' $(__git_lock_labels)
      elif (( CURRENT == 4 )); then
        _message 'git tag name'
      elif [[ $words[CURRENT-1] == "-m" ]]; then
        _message 'tag message'
      fi
      ;;
  esac
}

compdef _git-lock git-lock
